<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: shared_js/progress.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: shared_js/progress.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const BlissfulJs = require('blissfuljs'); // module adds Bliss to window object for us, use Bliss. and Bliss.$. for $ and $$
const debug = require('debug')('thisco:progress.js');
import _ from 'lodash';

import { CircleSegments } from '../ext_custom/CircleSegments';

/**
 * 
 * Sets up progress bar and progress watching:
 * - checks `table.ProgressBarContainer` and `div#thiscoObs>div.thisco-obs-content` selectors work
 * - adds relevant elements into `div#thiscoObs>div.thisco-obs-content`
 * - update function checks Qualtrics progress
 * - makes guess at Qualtrics weighting of % (will need to have gone forward past first 'page' to do this)
 * - also checks for fieldsets with class `touched` (this will change to `is-dirty` when validation used)
 * and uses them to guess a 'fill-in' progress amount
 * - renders progress bars (mobile one and the circular bar for wider screens)
 * 
 * Module default function, when called returns an object with single function, update()
 *   
 * @module
 */
module.exports = function(){
    // sets up a progress bar and returns obj with one method- update
   
    // expects to see a few elements to work

    const selectors = ['table.ProgressBarContainer','div#thiscoObs>div.thisco-obs-content'];
    allSelectors = selectors.every(sel=>{return Bliss(sel) instanceof HTMLElement;});
    if (!allSelectors) {
        debug('unable to locate elements for progress watcher - if expecting check sequencing');
        return {
            update : _.noop
        };
    }

    // updates by:
    // taking Qualtrics value at minimum
    // Qualtrics weights pages by question number (incl. graphics)
    // so can guess interval after first page
    // and adds in all fieldsets with 'touched' class to the current score

    let progressWatcher = {
        lastQProgress : 0,
        lastQuestions : false,
        current : 0,
        // latestIncrementGuess : 0,
        lastInterval : 0,
        intervalGuess : false
    }, progressDial;

    const obs = Bliss(`div#thiscoObs>div.thisco-obs-content`);
    const progressBar = Bliss.create("div",{
        tagname:  'div',
        className : 'progress',
        style : { width : '50%'}
    });
    obs.prepend(Bliss.create("div",{
        className : "thisco-progress-bar",
        style : {
            'position' : 'fixed'
        },
        contents : [progressBar]
    }));
    obs.prepend(Bliss.create("div",{
        className : "thisco-progress-dial",
        style : {
            'aspect-ratio' : 1,
            'position' : 'relative'
        }
    }));
    const progressGrain = 50;
    progressDial = new CircleSegments({
        target : ".thisco-progress-dial",
        rotationStart : -90,
        activeColors : ["crimson"],
        canvasMBlur : false,
        rounded : false,
        segmentNo : progressGrain,
        startExplode: 0,
        startRadius : 800,
        startIntRadius : 0,
        recessColor: "rgb(243 165 185 / .5)"
    });
    progressDial.init();

    const update = (pageTurn=false)=>{

        debug({progressWatcher,pageTurn});

        const {lastQuestions,lastInterval,intervalGuess} = progressWatcher;

        // get current page stats
        const progressEl = Bliss(`table.ProgressBarContainer`);
        const prog = {};
        ['valuemin','valuemax','valuenow'].forEach(val=>{
            prog[val] = parseInt(progressEl.getAttribute(`aria-${val}`));
        });
        const qProgress = (prog.valuemax - prog.valuemin) > 0 ? prog.valuenow / (prog.valuemax - prog.valuemin) : 0;

        if (pageTurn) progressWatcher.lastInterval = qProgress - progressWatcher.lastQProgress;

        // if we can, guess interval
        if (pageTurn &amp;&amp; !intervalGuess &amp;&amp; isFinite(lastQuestions) &amp;&amp; isFinite(lastInterval)) {
            progressWatcher.intervalGuess = lastInterval / lastQuestions;
        }

        // const latestIncrementGuess = _.clamp(progressWatcher.lastInterval / _.clamp(Bliss.$("fieldset").length,1,999), 0, 999)
        const validFsets = Bliss.$("fieldset.touched").filter(fset=>!fset.className.includes('contains-invalid')).length;
        progressWatcher.current = !intervalGuess ? qProgress : qProgress + (validFsets * intervalGuess);

        const currentVisual = progressWatcher.current * progressGrain;

        // set progress bar

        progressBar._.style({
            width : `${progressWatcher.current * 100}%`
        });

        // set progress dial

        if ((progressDial.options.startIntRadius == 0) &amp;&amp; (progressWatcher.lastQProgress == 0) &amp;&amp; (qProgress > 0)) {
            progressDial.options.startIntRadius = 450;
            progressDial.setProgress(_.floor(currentVisual),0);
        }
        else if (progressWatcher.current > .99) {
            progressDial.options.startIntRadius = 0;
            progressDial.setProgress(_.ceil(currentVisual),0);
        }
        else {
            progressDial.setProgress(_.floor(currentVisual),15);
        }

        if (pageTurn) {
            _.assign(progressWatcher,{
                lastQProgress : qProgress,
                lastQuestions : !lastQuestions ?_.clamp(Bliss.$("div[questionid]").length,1,999) : lastQuestions,
                // latestIncrementGuess : _.clamp((qProgress - progressWatcher.lastQProgress) / progressWatcher.lastQuestions, 0, 999),
                // lastInterval : qProgress - progressWatcher.lastQProgress
            });
        }

    };
    progressWatcher.update = update;

    return progressWatcher;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-shared_js_custom_video.html">shared_js/custom_video</a></li><li><a href="module-shared_js_expand_textarea.html">shared_js/expand_textarea</a></li><li><a href="module-shared_js_header_footer.html">shared_js/header_footer</a></li><li><a href="module-shared_js_link_buttons.html">shared_js/link_buttons</a></li><li><a href="module-shared_js_messages.html">shared_js/messages</a></li><li><a href="module-shared_js_misc_fixes.html">shared_js/misc_fixes</a></li><li><a href="module-shared_js_multiline_text.html">shared_js/multiline_text</a></li><li><a href="module-shared_js_panel_choice.html">shared_js/panel_choice</a></li><li><a href="module-shared_js_progress.html">shared_js/progress</a></li><li><a href="module-shared_js_ranking_question.html">shared_js/ranking_question</a></li><li><a href="module-shared_js_skinjob_client.html">shared_js/skinjob_client</a></li><li><a href="module-shared_js_slideshow.html">shared_js/slideshow</a></li><li><a href="module-shared_js_thisco_icons.html">shared_js/thisco_icons</a></li><li><a href="module-shared_js_thisco_modals.html">shared_js/thisco_modals</a></li><li><a href="module-shared_js_validation.html">shared_js/validation</a></li></ul><h3>Classes</h3><ul><li><a href="module-shared_js_multiline_text-Multiline.html">Multiline</a></li></ul><h3>Events</h3><ul><li><a href="module-shared_js_messages.html#~event:addMessage">addMessage</a></li><li><a href="module-shared_js_messages.html#~event:bodyUpdate">bodyUpdate</a></li><li><a href="module-shared_js_messages.html#~event:killMessage">killMessage</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-deployment.html">Build and Deployment</a></li><li><a href="tutorial-development.html">Development</a></li><li><a href="tutorial-qualtrics.html">Qualtricksiness</a></li><li><a href="tutorial-survey_setup.html">Survey Setup</a></li><li><a href="tutorial-testing.html">Testing</a></li><li><a href="tutorial-tools.html">Tools</a></li><li><a href="tutorial-troubleshooting.html">Troubleshooting</a></li><li><a href="tutorial-validation.html">Validation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#disposableModal">disposableModal</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Wed Feb 01 2023 17:00:50 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
